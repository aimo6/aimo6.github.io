<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SSH秘钥校验流程</title>
    <link href="/2025/04/29/SSH%E7%A7%98%E9%92%A5%E6%A0%A1%E9%AA%8C%E6%B5%81%E7%A8%8B/"/>
    <url>/2025/04/29/SSH%E7%A7%98%E9%92%A5%E6%A0%A1%E9%AA%8C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>SSH: 即Secure Shell</p><hr><h3 id="一、密钥生成（初始化阶段）"><a href="#一、密钥生成（初始化阶段）" class="headerlink" title="一、密钥生成（初始化阶段）"></a><strong>一、密钥生成（初始化阶段）</strong></h3><ol><li><p><strong>生成密钥对</strong><br>用户在客户端（本地设备）通过 <code>ssh-keygen</code> 命令生成 <strong>公钥（Public Key）</strong> 和 <strong>私钥（Private Key）</strong>，两者是一一对应的非对称加密密钥对。  </p><ul><li><strong>公钥</strong>：用于加密数据或验证签名，可公开分享（无安全风险）。  </li><li><strong>私钥</strong>：用于解密数据或生成签名，需严格保密（泄露会导致身份伪造）。  </li><li><strong>常见算法</strong>：RSA（≥2048 位）、ED25519、ECDSA 等。</li></ul></li><li><p><strong>上传公钥到服务器</strong><br>用户将公钥内容（如 <code>id_rsa.pub</code>）添加到服务器的 <code>~/.ssh/authorized_keys</code> 文件中（或 GitHub 等平台的账户设置中）。  </p><ul><li>服务器存储所有授权用户的公钥，用于后续认证。</li></ul></li></ol><hr><h3 id="二、SSH-密钥校验的核心流程（以-GitHub-为例）"><a href="#二、SSH-密钥校验的核心流程（以-GitHub-为例）" class="headerlink" title="二、SSH 密钥校验的核心流程（以 GitHub 为例）"></a><strong>二、SSH 密钥校验的核心流程（以 GitHub 为例）</strong></h3><p>当客户端（如本地 Git）通过 SSH 连接服务器（如 GitHub）时，认证过程如下：</p><h4 id="1-客户端发起连接请求"><a href="#1-客户端发起连接请求" class="headerlink" title="1. 客户端发起连接请求"></a><strong>1. 客户端发起连接请求</strong></h4><ul><li>客户端向服务器发起 TCP 连接，协商 SSH 协议版本和加密算法。</li><li>客户端声明支持 <strong>密钥认证</strong> 方式。</li></ul><h4 id="2-服务器验证客户端身份（核心步骤）"><a href="#2-服务器验证客户端身份（核心步骤）" class="headerlink" title="2. 服务器验证客户端身份（核心步骤）"></a><strong>2. 服务器验证客户端身份（核心步骤）</strong></h4><ul><li><p><strong>步骤 1：服务器发送随机挑战（Challenge）</strong><br><strong>服务器生成一个随机字符串（挑战数据，<code>challenge</code>）</strong>，并发送给客户端。  </p><ul><li><em>关键点</em>：挑战由服务器生成，确保唯一性和防重放攻击。</li></ul></li><li><p><strong>步骤 2：客户端签名挑战</strong><br>客户端使用本地私钥对 <code>challenge</code> <strong>生成签名</strong>（实际是对 <code>challenge</code> 的哈希值加密），并将以下信息发送给服务器：  </p><ol><li>客户端公钥（或公钥指纹）；  </li><li>签名结果 <code>signature</code>。</li></ol></li><li><p><strong>步骤 3：服务器验证签名</strong>  </p><ol><li>服务器根据客户端公钥指纹，在 <code>authorized_keys</code> 中查找匹配的公钥；  </li><li><strong>用公钥解密签名</strong>，得到哈希值 <code>H1</code>；  </li><li>服务器本地计算 <code>challenge</code> 的哈希值 <code>H2</code>；  </li><li>对比 <code>H1</code> 和 <code>H2</code>：  <ul><li>一致 → 认证通过（客户端拥有私钥）；  </li><li>不一致 → 认证失败。</li></ul></li></ol></li></ul><h4 id="3-完成认证，建立加密通道"><a href="#3-完成认证，建立加密通道" class="headerlink" title="3. 完成认证，建立加密通道"></a><strong>3. 完成认证，建立加密通道</strong></h4><ul><li>认证通过后，双方协商生成会话密钥（Session Key），后续所有通信通过对称加密传输（如 AES），确保效率和安全性。</li></ul><hr><h3 id="三、关键技术点解析"><a href="#三、关键技术点解析" class="headerlink" title="三、关键技术点解析"></a><strong>三、关键技术点解析</strong></h3><h4 id="1-非对称加密与签名机制"><a href="#1-非对称加密与签名机制" class="headerlink" title="1. 非对称加密与签名机制"></a><strong>1. 非对称加密与签名机制</strong></h4><ul><li><strong>签名（Signing）</strong>：<br>客户端对 <code>challenge</code> 的哈希值用私钥加密生成签名（非对称加密的逆向操作）。  <ul><li>私钥的保密性确保只有合法用户能生成有效签名。</li></ul></li><li><strong>验证（Verification）</strong>：<br>服务器用公钥解密签名，得到哈希值。若与 <code>challenge</code> 的哈希一致，则证明签名有效。</li></ul><h4 id="2-known-hosts-文件的作用"><a href="#2-known-hosts-文件的作用" class="headerlink" title="2. known_hosts 文件的作用"></a><strong>2. <code>known_hosts</code> 文件的作用</strong></h4><ul><li><strong>防御中间人攻击（MITM）</strong>：<br>首次连接时，服务器会发送自己的主机公钥（非用户公钥），客户端需验证其指纹是否与官方公布的一致。  <ul><li>若验证通过，主机公钥指纹存入 <code>~/.ssh/known_hosts</code>；后续连接时自动比对，防止攻击者冒充服务器。</li></ul></li></ul><h3 id="四、疑问解答"><a href="#四、疑问解答" class="headerlink" title="四、疑问解答"></a><strong>四、疑问解答</strong></h3><h4 id="1-服务器认证客户端时，基本流程"><a href="#1-服务器认证客户端时，基本流程" class="headerlink" title="1. 服务器认证客户端时，基本流程"></a><strong>1. 服务器认证客户端时，基本流程</strong></h4><ul><li><strong>第一次交互</strong>：客户端发起连接请求，声明支持密钥认证方式。</li><li><strong>第二次交互</strong>：服务器生成随机挑战（<code>challenge</code>），并发送给客户端（<em>而非客户端自己生成</em>）。</li><li><strong>第三次交互</strong>：客户端用私钥对 <code>challenge</code> 签名，将签名返回服务器。</li><li><strong>服务器验证签名</strong>：用存储的公钥解密签名，若还原的 <code>challenge</code> 一致，则认证通过。</li></ul><p><strong>结论</strong>：实际是两次消息交互（服务器发送挑战，客户端返回签名），但整体流程包含多次通信（TCP 握手、协议协商等）。</p><hr><h4 id="2-非对称加密与身份验证原理"><a href="#2-非对称加密与身份验证原理" class="headerlink" title="2. 非对称加密与身份验证原理"></a><strong>2. 非对称加密与身份验证原理</strong></h4><ul><li><strong>非对称加密</strong>：公钥加密的数据只能用私钥解密，私钥签名的数据可用公钥验证。</li><li><strong>验证身份的流程</strong>：<ol><li>服务器发送一个随机挑战（<code>challenge</code>）。</li><li>客户端用私钥对 <code>challenge</code> 签名（本质是加密哈希值）。</li><li>服务器用公钥解密签名，得到哈希值，与本地计算的 <code>challenge</code> 哈希值比对。</li><li>若一致，证明客户端拥有私钥（因为只有私钥能生成有效签名）。</li></ol></li></ul><p><strong>关键点</strong>：私钥的保密性保证了只有合法用户能生成有效签名，公钥的公开性允许任何人验证签名。</p><hr><h4 id="3-签名解密后的结果是否唯一？"><a href="#3-签名解密后的结果是否唯一？" class="headerlink" title="3. 签名解密后的结果是否唯一？"></a><strong>3. 签名解密后的结果是否唯一？</strong></h4><ul><li><strong>是唯一的</strong>，但需满足以下条件：<ul><li>签名算法是确定性的（如 RSA 使用 PKCS#1 v1.5）或包含抗碰撞哈希（如 SHA-256）。</li><li>挑战（<code>challenge</code>）是唯一的（服务器随机生成，避免重放攻击）。</li></ul></li><li><strong>原理</strong>：签名本质是对挑战的哈希值用私钥加密。公钥解密签名后得到哈希值，若与服务器本地计算的哈希一致，则验证通过。</li></ul><hr><h4 id="4-为什么公钥泄露无风险？"><a href="#4-为什么公钥泄露无风险？" class="headerlink" title="4. 为什么公钥泄露无风险？"></a><strong>4. 为什么公钥泄露无风险？</strong></h4><ul><li><strong>公钥的特性</strong>：<ul><li>公钥是公开设计的，无法逆向推导出私钥（基于数学难题，如大数分解、椭圆曲线离散对数）。</li><li>公钥仅用于加密或验证签名，无法用于生成签名或解密数据。</li></ul></li><li><strong>攻击者仅有公钥时</strong>：<ul><li>无法冒充客户端（无私钥无法生成有效签名）。</li><li>无法解密已加密的数据（若用公钥加密，需私钥解密）。</li></ul></li><li><strong>风险仅存在于私钥泄露</strong>：私钥是身份的唯一凭证，必须严格保密。</li></ul><h4 id="5-公钥泄露后，劫持者能否破解传输的信息？"><a href="#5-公钥泄露后，劫持者能否破解传输的信息？" class="headerlink" title="5.公钥泄露后，劫持者能否破解传输的信息？"></a><strong>5.公钥泄露后，劫持者能否破解传输的信息？</strong></h4><p><strong>结论</strong>：即使公钥泄露，劫持者也无法直接解密 SSH 通信中的数据。</p><ul><li><strong>SSH 传输阶段使用对称加密</strong><br>SSH 认证通过后，客户端和服务器会协商一个 <strong>对称加密密钥（Session Key）</strong>，后续所有数据传输均通过对称加密（如 AES）进行。<ul><li>对称加密的密钥是临时生成的，且通过安全通道（如 Diffie-Hellman 密钥交换协议）协商，与公钥无直接关联。</li><li>公钥仅用于身份认证阶段，不参与数据加密。</li></ul></li><li><strong>公钥的作用限制</strong><ul><li>公钥的泄露仅意味着攻击者可以知道用户的公钥，但无法：<ol><li>推导出私钥（基于非对称加密算法的数学难题）；</li><li>解密已加密的 SSH 通信数据（因为数据由对称密钥加密）。</li></ol></li></ul></li><li><strong>客户端被劫持的特殊情况</strong><ul><li>若客户端被完全劫持（如恶意软件控制），攻击者可直接获取客户端的私钥和会话密钥，此时所有通信将暴露。</li><li>但这与公钥泄露无关，而是私钥或会话密钥泄露的问题。</li></ul></li></ul><hr><p><strong>6.加密与签名的区别</strong></p><p><strong>加密（Encryption）</strong></p><ul><li><strong>目的</strong>：确保数据 <strong>机密性</strong>（防止内容被窃听）。</li><li><strong>流程</strong>：<ol><li>发送方用 <strong>接收方的公钥</strong> 加密数据 → 生成密文；</li><li>接收方用 <strong>自己的私钥</strong> 解密 → 还原原始数据。</li></ol></li><li><strong>典型场景</strong>：A 向 B 发送加密消息，只有 B 能解密（因为 B 持有私钥）。</li></ul><p><strong>签名（Signing）</strong></p><ul><li><strong>目的</strong>：确保数据 <strong>完整性</strong> 和 <strong>身份认证</strong>（验证发送者身份）。</li><li><strong>流程</strong>：<ol><li>发送方对数据生成哈希值 → 用 <strong>自己的私钥</strong> 加密哈希值 → 生成签名；</li><li>接收方用 <strong>发送方的公钥</strong> 解密签名 → 得到哈希值 <code>H1</code>；</li><li>接收方本地计算数据的哈希值 <code>H2</code> → 对比 <code>H1</code> 和 <code>H2</code>。</li></ol></li><li><strong>典型场景</strong>：A 向 B 发送签名消息，B 验证签名是否由 A 的私钥生成。</li></ul><p><strong>关键区别</strong></p><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>加密</strong></th><th align="left"><strong>签名</strong></th></tr></thead><tbody><tr><td align="left"><strong>操作方向</strong></td><td align="left">公钥加密，私钥解密</td><td align="left">私钥签名，公钥验证</td></tr><tr><td align="left"><strong>核心目标</strong></td><td align="left">保密性</td><td align="left">身份认证 + 完整性</td></tr><tr><td align="left"><strong>密钥使用</strong></td><td align="left">他人公钥加密，自己私钥解密</td><td align="left">自己私钥签名，他人公钥验证</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>专业知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025力扣刷题记录</title>
    <link href="/2025/04/27/2025%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/04/27/2025%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="3270-求出数字答案"><a href="#3270-求出数字答案" class="headerlink" title="3270. 求出数字答案"></a><a href="https://leetcode.cn/problems/find-the-key-of-the-numbers/">3270. 求出数字答案</a></h1><h2 id="1-字符串判断"><a href="#1-字符串判断" class="headerlink" title="1.字符串判断"></a>1.字符串判断</h2><p>先把这三个数转为填充后的字符串，然后对每一位进行判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateKey</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2, <span class="hljs-type">int</span> num3)</span> &#123;<br>        List&lt;Integer&gt; numList = List.of(num1, num2, num3);<br>        ArrayList&lt;String&gt; strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        numList.forEach(num-&gt;&#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(Integer.toString(num));<br>            <span class="hljs-comment">// 在前面补0的个数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> - s.length();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; count;i++)&#123;<br>                s.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;0&quot;</span>);<br>            &#125;<br>            strings.add(String.valueOf(s));<br>        &#125;);<br>        <span class="hljs-comment">//System.out.println(&quot;strings = &quot; + strings);</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Character.MAX_VALUE;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">3</span>;j++)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> strings.get(j);<br>                min =  Math.min(min,s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            builder.append(min);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(builder.toString());<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-从最低位开始计算"><a href="#2-从最低位开始计算" class="headerlink" title="2. 从最低位开始计算"></a>2. 从最低位开始计算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateKey</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2, <span class="hljs-type">int</span> num3)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pow</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-comment">// 获取这三个数最小各位值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.min(num1 % <span class="hljs-number">10</span>, num2 % <span class="hljs-number">10</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(t, num3 % <span class="hljs-number">10</span>);<br>            ans = ans + min * pow;<br>            num1 /= <span class="hljs-number">10</span>;<br>            num2 /= <span class="hljs-number">10</span>;<br>            num3 /= <span class="hljs-number">10</span>;<br>            pow *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h1><p>思路就是用分别用一个计数器，分别记录0和（0,1)出现的次数，此时n0就是到目前为止出现的最后一个0的下标，n1同理。然后总是假设当前这块板是蓝色的，为它刷上蓝色，接着判断当前值是否等于1，如果是，则把它刷为白色，0也是同理，类似刷油漆的过程，旧的会被新的覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-comment">// 到第i个数为止，出现0的次数，也就是到目前为止，最后一个0的下标</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">n0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-comment">// 到第i个数为止，出现0和1的次数，也就是到目前为止，最后一个1的下标</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>           nums[i] = <span class="hljs-number">2</span>;<br>           <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">2</span>)&#123;<br>               nums[n1++] = <span class="hljs-number">1</span>;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">1</span>)&#123;<br>               nums[n0++] = <span class="hljs-number">0</span>;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="2444-统计定界子数组的数目"><a href="#2444-统计定界子数组的数目" class="headerlink" title="2444. 统计定界子数组的数目"></a><a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">2444. 统计定界子数组的数目</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> minK, <span class="hljs-type">int</span> maxK)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 窗口中最后一出现minK下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 窗口中最后一出现maxK下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 窗口左边界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-comment">// 寻找最后一次出现minK或者maxK的下标</span><br>            <span class="hljs-comment">// 为什么要这样做：因为当窗口确定时，[left,right]中一定存在minK和maxK，此时如果窗口中出现多个minK和maxK</span><br>            <span class="hljs-comment">// 如果对应的下标越靠后，能够确定的子数组越多，防止统计不到</span><br>            <span class="hljs-keyword">if</span>(num == minK)&#123;<br>                minIndex = i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num == maxK)&#123;<br>                maxIndex = i;<br>            &#125;<br>            <span class="hljs-comment">// 当出现一个小于minK或者大于maxK的值时，重置窗口</span><br>            <span class="hljs-keyword">if</span>( num &gt; maxK || num &lt; minK)&#123;<br>                left = i+<span class="hljs-number">1</span>;<br>                minIndex = -<span class="hljs-number">1</span>;<br>                maxIndex = -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 能够组成窗口时，累加答案</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(minIndex != -<span class="hljs-number">1</span> &amp;&amp; maxIndex != -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">// [left - minIndex - maxIndex - right] 或 [left - maxIndex - minIndex - right]</span><br>                <span class="hljs-comment">// 此时[left ... min]都是满足条件的子数组</span><br>                ans += Math.min(maxIndex, minIndex) - left + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="2302-统计得分小于-K-的子数组数目"><a href="#2302-统计得分小于-K-的子数组数目" class="headerlink" title="2302. 统计得分小于 K 的子数组数目"></a><a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/">2302. 统计得分小于 K 的子数组数目</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">long</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;right &lt; nums.length;right++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[right];<br>        <span class="hljs-comment">// 将当前数加入窗口中</span><br>        sum += num;<br>        <span class="hljs-comment">// 内循环，如果当前窗口和*窗口长度 大于等于 k时，移动左窗口，直至窗口满足条件</span><br>        <span class="hljs-keyword">while</span> (sum * (right - left + <span class="hljs-number">1</span>) &gt;= k)&#123;<br>            sum -= nums[left];<br>            left++;<br>        &#125;<br>        <span class="hljs-comment">// 这里是随着当前数加入窗口后当增加的子数组个数，而不是当前窗口内能够组成的子数组个数</span><br>        <span class="hljs-comment">// 比如[2,1,4,3]当4加入窗口中时，增加的子数组为[2,1,4,3],[1,4,3],[4,3],[4]共计4个</span><br>        <span class="hljs-comment">// 因为之前的已经统计过了，不用再次计算</span><br>        ans += right - left + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2962-统计最大元素出现至少-K-次的子数组"><a href="#2962-统计最大元素出现至少-K-次的子数组" class="headerlink" title="2962. 统计最大元素出现至少 K 次的子数组"></a><a href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/">2962. 统计最大元素出现至少 K 次的子数组</a></h1><p>这道题目和前面的那些滑动窗口题目类似，先是扩张窗口使得窗口内最大元素个数为k，然后在内循环中收缩窗口，直至窗口内最大元素个数为k-1（此时是窗口恰好不满足的情况）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Arrays.stream(nums).max().getAsInt();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//当前窗口内最大元素的个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;right &lt; nums.length;right++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[right];<br>        <span class="hljs-keyword">if</span>(num == max)&#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-comment">//内循环，使得窗口内最大元素个数小于k</span><br>        <span class="hljs-keyword">while</span> (count &gt;= k)&#123;<br>            <span class="hljs-keyword">if</span>(nums[left] == max)&#123;<br>                count--;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-comment">//右指针固定时，left 的位置保证了所有左端点 &lt; left 对应的子数组 [left_start, right] 必             //然包含至少 k 个最大值。ans += left 正是累加这些合法的左端点数目</span><br>        ans += left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h1><p>这道题目是贪心算法思想，在划分时如果包含一个字符，则该次划分必须包含所有字符。</p><p>算法步骤：</p><p>1：计算字符串s中每个字符最后一次出现的位置。</p><p>2：对字符串进行遍历，在遍历中不断更新右窗口最大下标。</p><p>3：当到达右窗口时，统计当前划分，重新赋值，开始下一轮划分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>       <span class="hljs-comment">//统计每个字符的最大下标</span><br>       <span class="hljs-type">int</span>[] maxIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>           maxIndex[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>       &#125;<br>       ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-comment">//记录当前统计的边界</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>           <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>           right = Math.max(right,maxIndex[c - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>           <span class="hljs-comment">//到达当前一次划分边界，统计结果</span><br>           <span class="hljs-keyword">if</span>(i == right)&#123;<br>               ans.add(right - left + <span class="hljs-number">1</span>);<br>               left = i+<span class="hljs-number">1</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="1295-统计位数为偶数的数字"><a href="#1295-统计位数为偶数的数字" class="headerlink" title="1295. 统计位数为偶数的数字"></a><a href="https://leetcode.cn/problems/find-numbers-with-even-number-of-digits/">1295. 统计位数为偶数的数字</a></h1><h2 id="1-直接统计位数"><a href="#1-直接统计位数" class="headerlink" title="1.直接统计位数"></a>1.直接统计位数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>)&#123;<br>                count++;<br>                num /= <span class="hljs-number">10</span>;<br>            &#125;;<br>            <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/markdown-img/2025%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/image-20250430101333522.png" alt="image-20250430101333522"></p><h2 id="2-使用对数函数"><a href="#2-使用对数函数" class="headerlink" title="2.使用对数函数"></a>2.使用对数函数</h2><p>以10为底的对数函数向下取整为int可以获取除了第一位之外的位数，对结果加一即可获取x的位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.log10(num) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/markdown-img/2025%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/image-20250430101547308.png" alt="image-20250430101547308"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>力扣</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/04/27/hello-world/"/>
    <url>/2025/04/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
